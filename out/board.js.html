<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: board.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: board.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>let searchresults = [];
let currenttask = 0;
let currentdragged;
let currentdraggedarray;
let task;
/**
 * start functions onload, render tasks, empty fields informations and empty Box hover 
 */
function boardinit() {
    renderTasks();
    showEmptyHtmlTodo();
    showEmptyHtmlInprogress();
    showEmptyHtmlAwaitfeedback();
    showEmptyHtmlDone();
    emptyBoxHtml();
}

/**
 * start function creat hover Box, return to function and set const 
 * iterate through the IDs for the html places 
 * get ID and place HTML
 */
function emptyBoxHtml() {
    const empty = hoverHtml();
    ["to_do_place", "in_progress_place", "await_feedback_place", "done_place"].forEach((container) => {
        document.getElementById(container).innerHTML += empty;
    })
}

/**
 * if no elements of an array are present, the empty task field is created and placed using the ID
 * @param {element} elementId - element ID from html 
 * @param {array} userProperty - one of four arrays
 * @param {element} emptyTaskFunction - one of four html elements
 */
function updateEmptyHtml(elementId, userProperty, emptyTaskFunction) {
    if (users[loaduser][userProperty] == 0) {
        const empty = emptyTaskFunction();
        document.getElementById(elementId).innerHTML = empty;
    }
}

/**
 * get the id, array and html element for todo
 */
function showEmptyHtmlTodo() {
    updateEmptyHtml("to_do_place", "todo", emptyTaskFieldTodo);
}

/**
 * get the id, array and html element for tasksinprogress
 */
function showEmptyHtmlInprogress() {
    updateEmptyHtml("in_progress_place", "tasksinprogress", emptyTaskFieldInprogress);
}

/**
 * get the id, array and html element for awaitingfeedback
 */
function showEmptyHtmlAwaitfeedback() {
    updateEmptyHtml("await_feedback_place", "awaitingfeedback", emptyTaskFieldAwaitfeedback);
}

/**
 * get the id, array and html element for done
 */
function showEmptyHtmlDone() {
    updateEmptyHtml("done_place", "done", emptyTaskFieldDone);
}

/**
 * get the ID for close the screen with the class 
 * clear the seleted contact array
 * start init function, to refresh the page
 */
function closeCard() {
    document.getElementById("fullscreen_information").classList.add("d-none");
    selectedcontacts = [];
    boardinit();
}

/**
 * open the generated HTML, to add an task
 * @param {string} array - defines the space for the created task
 */
function bordAddNewTask(array) {
    const card = bordAddTaskFieldHtml();
    let getplacecard = document.getElementById("add_bordtask_data");
    document.getElementById("fullscreen_information").classList.remove("d-none");
    getplacecard.innerHTML = card;
    fillAddTaskSection(array);
}

/**
 * uses if-else statements to determine the parent container's ID and
 * triggers specific actions accordingly, 
 * such as dragging tasks and opening tasks with specific statuses
 * @param {number} id - identifer for one of four arrays
 * @param {object} element - HTML element triggered that event
 */
function openBordTask(id, element) {
    element.parentElement &amp;&amp; element.parentElement.id === "to_do_place" ? (dragTodo(id), openTask(id, "todo")) : 
    element.parentElement &amp;&amp; element.parentElement.id === "in_progress_place" ? (dragInProgress(id), openTask(id, "tasksinprogress")) : 
    element.parentElement &amp;&amp; element.parentElement.id === "await_feedback_place" ? (dragAwaitFeedback(id), openTask(id, "awaitingfeedback")) : 
    element.parentElement &amp;&amp; element.parentElement.id === "done_place" &amp;&amp; (dragDone(id), openTask(id, "done"));
}

/**
 * populates a task card with data based on the provided index and task type and
 * get all task informations
 * @param {number} i - identifer for one of four arrays
 * @param {type} key - one of four array
 */
function openTask(i, key) {
    let getplacecard = document.getElementById("add_bordtask_data");
    document.getElementById("fullscreen_information").classList.remove("d-none");
    const selectarray = currentdraggedarray[i];
    const { categorytodo, titletodo, descriptiontodo, subtaskstodo, contactstodo, priotodo, datetodo } = informationTodo(selectarray);
    const choosencategory = selectCategory(categorytodo);
    const choosensubtasks = selectSubtasks(subtaskstodo);
    const getsubtaskhtml = selectSubtaskHtml(choosensubtasks, selectarray);
    const choosenpriority = selectPriorityOpenTask(priotodo);
    const selectcontacts = selectContactsOpenTask(contactstodo);
    getplacecard.innerHTML = fullTaskHtml(choosencategory, titletodo, descriptiontodo, i, choosenpriority, datetodo, getsubtaskhtml, selectcontacts, key);
}

/**
 * updates a task card with data based on the provided index and task type and
 * fetches task information 
 * updates the HTML of the task card
 * initializes task addition, edits contacts, and subtasks
 * @param {number} i - identifer for one of four arrays
 * @param {type} key - one of four array
 */
function editSingleTask(i, key) {
    let getplacetaskvariantbord = document.getElementById("add_bordtask_data");
    const selectarray = currentdraggedarray[i];
    const { categorytodo, titletodo, descriptiontodo, subtaskstodo, contactstodo, priotodo, datetodo } = informationTodo(selectarray);
    categorytodo;
    const choosenpriority = selectPriority(priotodo);
    getplacetaskvariantbord.innerHTML = editTaskHtml(titletodo, descriptiontodo, i, choosenpriority, datetodo, key);
    initAddTask(i, priotodo);
    editContactsFactory(contactstodo);
    editSubtaskFactory(subtaskstodo);
}

/**
 * refreshes task sections with user data
 * clears each section, fetches tasks based on section ID from user data
 * displays task HTML in each section
 */
function renderTasks() {
    const taskSections = ["to_do_place", "in_progress_place", "await_feedback_place", "done_place"];
    taskSections.forEach((sectionId) => {
        let sectionElement = document.getElementById(sectionId);
        sectionElement.innerHTML = ``;
        let tasks = sectionId === "to_do_place" ? users[loaduser]["todo"] : sectionId === "in_progress_place" ? users[loaduser]["tasksinprogress"] : 
        sectionId === "await_feedback_place" ? users[loaduser]["awaitingfeedback"] : sectionId === "done_place" ? users[loaduser]["done"] : [];
        tasks.forEach((task, index) => {
            showTaskHtml(task, index, sectionId);
        });
    });
}

/**
 * retrieves the HTML element  
 * extracts specific details from the object using helper function
 * generates HTML content for the task using the extracted information
 * create the HTML
 * @param {object} task - containing information about the task
 * @param {number} index - identifer for one of four arrays
 * @param {string} sectionId - representing one of four possible IDs for sections 
 */
function showTaskHtml(task, index, sectionId) {
    let sectionElement = document.getElementById(sectionId);
    const { categorytodo, titletodo, descriptiontodo, subtaskstodo, contactstodo, priotodo } = informationTodo(task);
    const { choosencategory, choosenpriority, selectedCheckboxCount, barupdated, choosensubs, selectcontacts } = informationsFactory(categorytodo, priotodo, subtaskstodo, contactstodo);
    sectionElement.innerHTML += todoTaskHtml(choosencategory, titletodo, descriptiontodo, index, barupdated, selectcontacts, choosenpriority, choosensubs, selectedCheckboxCount, sectionId);
}

/**
 * extracts properties from a object
 * returns them in a new object with renamed keys
 * @param {object} task - containing information about the task
 * @returns 
 */
function informationTodo(task) {
    let { category, title, description, subtasks, contacts, prio, date } = task;
    return { categorytodo: category, titletodo: title, descriptiontodo: description, subtaskstodo: subtasks, contactstodo: contacts, priotodo: prio, datetodo: date };
}

/**
 * helper functions to process each array and generate specific informations
 * returns an object containing the processed information
 * @param {array} category - representing task categories
 * @param {array} priority - representing task priorities
 * @param {array} subtasks - representing subtasks of a task
 * @param {array} contacts - representing contacts related to the task
 * @returns 
 */
function informationsFactory(category, priority, subtasks, contacts) {
    const choosencategory = selectCategory(category);
    const choosenpriority = selectPriority(priority);
    const selectedCheckboxCount = countSelectedCheckboxes(subtasks);
    const barupdated = updateProgressBar(subtasks, selectedCheckboxCount);
    const choosensubs = choosenSubtasks(subtasks, selectedCheckboxCount);
    const selectcontacts = selectContacts(contacts);
    return { choosencategory, choosenpriority, selectedCheckboxCount, barupdated, choosensubs, selectcontacts };
}

/**
 * choose the right category 
 * @param {array} category - representing task categories and returns HTML content 
 * @returns 
 */
function selectCategory(category) {
    return category == "Technical Task" ? technicalTaskHtml() : userTaskHtml();
}

/**
 * creates HTML for displaying contacts and return styled HTML
 * iterates through the array of contacts, generates a profile badge for each,
 * only contacts with a non-empty first name are processed
 * @param {array} contactstodo - representing task contacts and returns HTML content 
 * @returns 
 */
function selectContacts(contactstodo) {
    let contacthtml = "";
    for (let s = 0; s &lt; contactstodo.length; s++) {
        const contact = contactstodo[s];
        if (!contact.firstname) continue;
        const abbreviation = contact.firstname.charAt(0) + contact.lastname.charAt(0);
        contacthtml += `
            &lt;div class="contact-name-place">
                &lt;span class="profile-badge" style="background-color: ${contact.color};">${abbreviation}&lt;/span>
            &lt;/div>`;
    }
    return contacthtml;
}

/**
 * creates HTML for displaying contacts and return styled HTML with names 
 * iterates through the array of contacts, generates a profile badge for each,
 * only contacts with a non-empty first name are processed
 * @param {array} contactstodo - representing task contacts and returns HTML content
 * @returns 
 */
function selectContactsOpenTask(contactstodo) {
    let contacthtml = "";
    for (let s = 0; s &lt; contactstodo.length; s++) {
        const contact = contactstodo[s];
        if (!contact.firstname) continue;
        const selectfirstnamecon = contact["firstname"];
        const selectlastnamecon = contact["lastname"];
        const abbreviation = contact.firstname.charAt(0) + contact.lastname.charAt(0);
        contacthtml += `
            &lt;div class="contact-name-place">
                &lt;span class="profile-badge" style="background-color: ${contact.color};">${abbreviation}&lt;/span>
                &lt;span>${selectfirstnamecon}&amp;nbsp;${selectlastnamecon}&lt;/span>
            &lt;/div>`;
    }
    return contacthtml;
}

/**
 * returns HTML content based on the priority of a task, utilizing different functions for each priority level
 * @param {array} priority - representing task priorities
 * @returns 
 */
function selectPriority(priority) {
    return priority === "urgent" ? urugentPrioHtml() : priority === "low" ? lowPrioHtml() : priority === "medium" ? mediumPrioHtml() : mediumPrioHtml();
}

/**
 * returns HTML content based on the priority of a task, utilizing different functions for each priority level with there names
 * @param {array} priority - representing task priorities
 * @returns 
 */
function selectPriorityOpenTask(priority) {
    return priority === "urgent" ? urugentPrioHtmlOpenTask() : priority === "low" ? lowPrioHtmlOpenTask() : 
    priority === "medium" ? mediumPrioHtmlOpenTask() : mediumPrioHtmlOpenTask();
}

/**
 * displays task categories in a larger format,
 * utilizing different HTML generation functions for technical tasks and user tasks
 * @param {array} category - representing the task category
 */
function showTaskCategoryBig(category) {
    const html = category === "Technical Task" ? technicalTaskHtml() : userTaskHtml();
    document.getElementById("task_variant_bord").innerHTML = html;
}

/**
 * allow an item to drop of, when is dragged over
 * @param {object} ev - ensures proper drop handling by disabling default drag behavior
 */
function allowDrop(ev) {
    ev.preventDefault();
}

/**
 * determines the parent element's ID of the dragged item and 
 * triggers a corresponding drag function based on that ID
 * if a matching function is found, it calls it with the ID
 * @param {number} id - identifer for one of four arrays
 * @param {object} element - HTML element triggered that event
 */
function drag(id, element) {
    const parentElementId = element.parentElement ? element.parentElement.id : null;
    const dragFunctions = {
        to_do_place: dragTodo,
        in_progress_place: dragInProgress,
        await_feedback_place: dragAwaitFeedback,
        done_place: dragDone,
    };
    const dragFunction = dragFunctions[parentElementId];
    dragFunction ? dragFunction(id) : null;
}

/**
 * generates HTML informations for a progress bar based on the length of an array subtask and
 * and a count of selected checkboxes
 * if there's only one subtask or none, it returns an empty value
 * otherwise, it creates and returns HTML informations for the progress bar
 * @param {array} subtasks - returns either an empty value or HTML informations for a progress bar
 * @param {number} selectedCheckboxCount - number of selected checkbox
 * @returns 
 */
function choosenSubtasks(subtasks, selectedCheckboxCount) {
    let subtasklength = subtasks.length;
    if (subtasklength &lt;= 1) {
        let nullsubs = empty();
        return nullsubs;
    } else {
        let checksubs = subtaskProgressbarHtml(subtasklength - 1, selectedCheckboxCount);
        return checksubs;
    }
}

/**
 * returning either an empty value or HTML for the progress bar based on completion percentage
 * @param {array} subtasks - returns either an empty value or the HTML for the progress bar
 * @param {number} selectedCheckboxCount - number of selected checkbox
 * @returns 
 */
function updateProgressBar(subtasks, selectedCheckboxCount) {
    let percent = selectedCheckboxCount === 1 ? 0 : Math.round((selectedCheckboxCount / subtasks.length) * 100);
    if (subtasks.length &lt;= 1) {
        let nullsubs = empty();
        return nullsubs;
    } else {
        let checksubs = createProgressBar(percent);
        return checksubs;
    }
}

/**
 * iterates over the array, extracting the "name" property from each subtask object and storing it in a new array
 * @param {array} subtaskstodo - representing the task subtasks
 * @returns 
 */
function selectSubtasks(subtaskstodo) {
    let iteratedList = [];
    for (let st = 1; st &lt; subtaskstodo.length; st++) {
        let sublistplace = subtaskstodo[st];
        let list = sublistplace["name"];
        iteratedList.push(list);
    }
    return iteratedList;
}

/**
 * asynchronously updates the checkbox status and 
 * create the input style as image
 * @param {number} index - identifer for one of four arrays
 * @param {boolean} isChecked - true or false from the checked input
 */
async function updateSelectedCheckboxes(index, isChecked) {
    task["subtasks"][index]["isChecked"] = isChecked;
    await saveToServer();

    const imgElement = document.getElementById(`subtask${index}`);
    if (isChecked == true) {
        imgElement.src = "./assets/img/bord_check.png";
    } else {
        imgElement.src = "./assets/img/bord_uncheck.png";
    }
}

/**
 * iterates through the array, incrementing the count when a checkbox is checked, and returns the total count
 * @param {array} subtaskstodo - representing the task subtasks
 * @returns 
 */
function countSelectedCheckboxes(subtaskstodo) {
    let count = 1;
    for (let checkindex = 0; checkindex &lt; subtaskstodo.length; checkindex++) {
        const check = subtaskstodo[checkindex]["isChecked"];
        check == true ? count++ : "";
    }
    return count;
}

/**
 * generates HTML for each subtask based on two arrays, sublist and selectarray
 * determines the checkbox status and image source for each subtask and returns the HTML
 * updates the task object before returning the HTML
 * @param {array} sublist - representing the task subtasks
 * @param {array} selectarray - representing the task subtasks from the selected array
 * @returns 
 */
function selectSubtaskHtml(sublist, selectarray) {
    let html = "";
    for (let i = 0; i &lt; sublist.length; i++) {
        const subtask = sublist[i];
        const isChecked = selectarray["subtasks"][i]["isChecked"] ? "checked" : "";
        const imgSrc = selectarray["subtasks"][i]["isChecked"] ? "./assets/img/bord_check.png" : "./assets/img/bord_uncheck.png";
        html += generateSubsHtml(i, isChecked, subtask, imgSrc);
    }
    task = selectarray;
    return html;
}

/**
 * sets the global currentdragged variable to the provided id
 * assigns the corresponding todo array from the users object to global currentdraggedarray
 * @param {number} id - identifer for one of four arrays
 */
function dragTodo(id) {
    currentdragged = id;
    currentdraggedarray = users[loaduser]["todo"];
}

/**
 * sets the global currentdragged variable to the provided id
 * assigns the corresponding tasksinprogress array from the users object to global currentdraggedarray
 * @param {number} id - identifer for one of four arrays
 */
function dragInProgress(id) {
    currentdragged = id;
    currentdraggedarray = users[loaduser]["tasksinprogress"];
}

/**
 * sets the global currentdragged variable to the provided id
 * assigns the corresponding awaitingfeedback array from the users object to global currentdraggedarray
 * @param {number} id - identifer for one of four arrays
 */
function dragAwaitFeedback(id) {
    currentdragged = id;
    currentdraggedarray = users[loaduser]["awaitingfeedback"];
}

/**
 * sets the global currentdragged variable to the provided id
 * assigns the corresponding done array from the users object to global currentdraggedarray
 * @param {number} id - identifer for one of four arrays
 */
function dragDone(id) {
    currentdragged = id;
    currentdraggedarray = users[loaduser]["done"];
}

/**
 * ensures proper drop handling by preventing the default drag behavior
 * updates the selected droparray by pushing the item from the currentdraggedarray, 
 * then removes the item from currentdraggedarray
 * initializes the board and saves the changes to the server
 * @param {object} ev - ensures proper drop handling by disabling default drag behavior
 * @param {array} droparray - the choosen array
 */
async function dropOn(ev, droparray) {
    ev.preventDefault();
    let select = users[loaduser];
    select[droparray].push(currentdraggedarray[currentdragged]);
    currentdraggedarray.splice(currentdragged, 1);
    boardinit();
    await saveToServer();
}

/**
 * revents the propagation of the event to parent elements
 * @param {object} event - captures the click action
 */
function noCloseContent(event) {
    event.stopPropagation();
}

/**
 * returns an object with references to HTML elements identified by their IDs
 * @returns 
 */
function searchTaskPlace() {
    return {
        todoplace: document.getElementById(`to_do_place`), inprogressplace: document.getElementById(`in_progress_place`),
        awaitfeedbackplace: document.getElementById(`await_feedback_place`), doneplace: document.getElementById(`done_place`),
    };
}

/**
 * retrieves the value from the search input element, 
 * trims whitespace, converts it to lowercase, and 
 * returns an object with the search string and its length
 * @returns 
 */
function getSearchInput() {
    const search = document.getElementById("search_input").value.trim().toLowerCase();
    return { search, searchlength: search.length };
}


/**
 * ilters and renders results based on the search query if the query length is at least one character 
 * otherwise, it initializes the board
 */
function searchTitleStart() {
    const { search, searchlength } = getSearchInput();
    const { todoplace, inprogressplace, awaitfeedbackplace, doneplace } = searchTaskPlace();
    searchlength >= 1 ? renderResults(filterResults(search), todoplace, inprogressplace, awaitfeedbackplace, doneplace) : boardinit();
}

/**
 * sorts tasks based on input, returning filtered results
 * @param {object} search - refers to the keyword
 * @returns 
 */
function filterResults(search) {
    return {
        resultstodo: filterArray(users[loaduser]["todo"], search), resultsinprogress: filterArray(users[loaduser]["tasksinprogress"], search),
        resultsawaitfeedback: filterArray(users[loaduser]["awaitingfeedback"], search), resultsdone: filterArray(users[loaduser]["done"], search),
    };
}

/**
 * filters an array based on a search term found in each item's title
 * @param {arry} array - representing one of four arrays
 * @param {object} search - refers to the keyword
 * @returns 
 */
function filterArray(array, search) {
    return array.filter((item) => item.title.toLowerCase().includes(search));
}

/**
 * places filtered task results into their corresponding bord categories
 * @param {object} filteredResults - filtered task results
 * @param {string} todoplace - placement for tasks to do
 * @param {string} inprogressplace - placement for tasks in progress
 * @param {string} awaitfeedbackplace - placement for tasks awaiting feedback
 * @param {string} doneplace - placement for completed tasks
 */
function renderResults(filteredResults, todoplace, inprogressplace, awaitfeedbackplace, doneplace) {
    renderResultsCategory(filteredResults.resultstodo, todoplace);
    renderResultsCategory(filteredResults.resultsinprogress, inprogressplace);
    renderResultsCategory(filteredResults.resultsawaitfeedback, awaitfeedbackplace);
    renderResultsCategory(filteredResults.resultsdone, doneplace);
}

/**
 * updates a webpage element with either filtered task results or a message if no results are found
 * @param {*} results - filtered task results
 * @param {*} place - placement for tasks
 */
function renderResultsCategory(results, place) {
    place.innerHTML = "";
    results.length &lt;= 0 ? (place.innerHTML = nothingFound()) : results.forEach((item, index) => showHtml(item, place, index));
}

/**
 * places filtered task items in their designated locations
 * @param {object} item - filtered itmes
 * @param {string} place - placement for tasks
 * @param {number} index - identifer for one of four arrays
 */
function showHtml(item, place, index) {
    place.id === "to_do_place" &amp;&amp; showTaskHtml(item, index, "to_do_place");
    place.id === "in_progress_place" &amp;&amp; showTaskHtml(item, index, "in_progress_place");
    place.id === "await_feedback_place" &amp;&amp; showTaskHtml(item, index, "await_feedback_place");
    place.id === "done_place" &amp;&amp; showTaskHtml(item, index, "done_place");
}

/**
 * removes a task from the current array
 * @param {number} i - identifer for one of four arrays
 */
async function deleteSingleTask(i) {
    currentdraggedarray.splice(i, 1);
    boardinit();
    closeCard();
    await saveToServer();
}

/**
 * stores user data, if the user is not a guest, 
 * otherwise, it stores the data as a session storage item for the user
 */
async function saveToServer() {
    sessionStorage.getItem("Guest") === null ? await setItem("users", JSON.stringify(users)) : sessionStorage.setItem("Guest", JSON.stringify(users));
}

/**
 * iterates through an array of contacts, selects each contact by its ID
 * @param {array} selectcontacts - representing the array contacts
 */
function editContactsFactory(selectcontacts) {
    for (let j = 0; j &lt; selectcontacts.length; j++) {
        const selected = selectcontacts[j];
        const idselected = selected["id"];
        selectContactById(idselected);
    }
}

/**
 * iterates through an array of subtasks 
 * if a subtask has a name, it adds the subtasks
 * @param {array} subtaskstodo - representing the array subtasks
 */
function editSubtaskFactory(subtaskstodo) {
    for (let h = 0; h &lt; subtaskstodo.length; h++) {
        const selected = subtaskstodo[h];
        if (selected.name) addSubtask(0, selected);
    }
}

/**
 * identifies the parent ID of an HTML element and initiates task dragging accordingly
 * opening the move task menu
 * @param {number} i - identifer for one of four arrays
 * @param {element} ele - html element
 */
function openMoveMenue(i, ele) {
    const parentId = ele.parentElement.parentElement.parentElement.id;
    parentId === 'to_do_place' ? (dragTodo(i), openMoveTaskMenu("todo")) : parentId === 'in_progress_place' ? (dragInProgress(i), openMoveTaskMenu("tasksinprogress")) :
    parentId === 'await_feedback_place' ? (dragAwaitFeedback(i), openMoveTaskMenu("awaitingfeedback")) : parentId === 'done_place' &amp;&amp; (dragDone(i), openMoveTaskMenu("done"));
}

/**
 * function displays the move task menu based on the selected array and 
 * highlights the corresponding option
 * @param {object} movekey - the selected array
 */
function openMoveTaskMenu(movekey) {
    let getplacecard = document.getElementById("add_bordtask_data");
    document.getElementById("fullscreen_information").classList.remove("d-none");
    getplacecard.innerHTML = moveTaskMenue(movekey);
    movekey === "todo" ? document.getElementById("light_todo").classList.add("highlight-color") : movekey === "tasksinprogress" ? document.getElementById("light_inprogress").classList.add("highlight-color") :
    movekey === "awaitingfeedback" ? document.getElementById("light_awaitfeedback").classList.add("highlight-color") : movekey === "done" &amp;&amp; document.getElementById("light_done").classList.add("highlight-color");
}

/**
 * moves a task from the current dragged array to the specified category array, 
 * updates the board, saves to the server, and hides the fullscreen information
 * @param {array} category - representing the array category
 */
async function moveTask(category) {
    let select = users[loaduser];
    select[category].push(currentdraggedarray[currentdragged]);
    currentdraggedarray.splice(currentdragged, 1);
    boardinit();
    await saveToServer();
    document.getElementById("fullscreen_information").classList.add("d-none");
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#LoginLocalstorage">LoginLocalstorage</a></li><li><a href="global.html#Loginsessionstorage">Loginsessionstorage</a></li><li><a href="global.html#addAddTaskEventListeners">addAddTaskEventListeners</a></li><li><a href="global.html#addDataFromInputs">addDataFromInputs</a></li><li><a href="global.html#addDataToCurrentTask">addDataToCurrentTask</a></li><li><a href="global.html#addPrio">addPrio</a></li><li><a href="global.html#addSubtask">addSubtask</a></li><li><a href="global.html#addToTasks">addToTasks</a></li><li><a href="global.html#allowDrop">allowDrop</a></li><li><a href="global.html#applyChangesToTask">applyChangesToTask</a></li><li><a href="global.html#backToLogin">backToLogin</a></li><li><a href="global.html#boardinit">boardinit</a></li><li><a href="global.html#bordAddNewTask">bordAddNewTask</a></li><li><a href="global.html#buildNewContactArray">buildNewContactArray</a></li><li><a href="global.html#capitalize">capitalize</a></li><li><a href="global.html#changeLoginImg">changeLoginImg</a></li><li><a href="global.html#changeSigninImg">changeSigninImg</a></li><li><a href="global.html#changeSubtaskIcons">changeSubtaskIcons</a></li><li><a href="global.html#changeTaskInUserArray">changeTaskInUserArray</a></li><li><a href="global.html#changeViewMobile">changeViewMobile</a></li><li><a href="global.html#choosenSubtasks">choosenSubtasks</a></li><li><a href="global.html#clearAddTaskArrays">clearAddTaskArrays</a></li><li><a href="global.html#clearAddTaskForm">clearAddTaskForm</a></li><li><a href="global.html#clearContactDetails">clearContactDetails</a></li><li><a href="global.html#clearContainers">clearContainers</a></li><li><a href="global.html#clearErrorStyle">clearErrorStyle</a></li><li><a href="global.html#clearInput">clearInput</a></li><li><a href="global.html#clearInputs">clearInputs</a></li><li><a href="global.html#clearPrioButtons">clearPrioButtons</a></li><li><a href="global.html#closeCard">closeCard</a></li><li><a href="global.html#closeContactsSideMenu">closeContactsSideMenu</a></li><li><a href="global.html#closeMenu">closeMenu</a></li><li><a href="global.html#closeOverlay">closeOverlay</a></li><li><a href="global.html#confirmChangeSubtask">confirmChangeSubtask</a></li><li><a href="global.html#contactsIfElse">contactsIfElse</a></li><li><a href="global.html#countSelectedCheckboxes">countSelectedCheckboxes</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#deleteContact">deleteContact</a></li><li><a href="global.html#deleteSingleTask">deleteSingleTask</a></li><li><a href="global.html#deleteSubtask">deleteSubtask</a></li><li><a href="global.html#dontChangeFocus">dontChangeFocus</a></li><li><a href="global.html#drag">drag</a></li><li><a href="global.html#dragAwaitFeedback">dragAwaitFeedback</a></li><li><a href="global.html#dragDone">dragDone</a></li><li><a href="global.html#dragInProgress">dragInProgress</a></li><li><a href="global.html#dragTodo">dragTodo</a></li><li><a href="global.html#dropOn">dropOn</a></li><li><a href="global.html#editContactsFactory">editContactsFactory</a></li><li><a href="global.html#editSingleTask">editSingleTask</a></li><li><a href="global.html#editSubtask">editSubtask</a></li><li><a href="global.html#editSubtaskFactory">editSubtaskFactory</a></li><li><a href="global.html#emptyBoxHtml">emptyBoxHtml</a></li><li><a href="global.html#encryptPassword1">encryptPassword1</a></li><li><a href="global.html#encryptPassword2">encryptPassword2</a></li><li><a href="global.html#encryptPassword2IfElse">encryptPassword2IfElse</a></li><li><a href="global.html#filterArray">filterArray</a></li><li><a href="global.html#filterResults">filterResults</a></li><li><a href="global.html#formatDate">formatDate</a></li><li><a href="global.html#formatName">formatName</a></li><li><a href="global.html#formatOutputDate">formatOutputDate</a></li><li><a href="global.html#fstopPropagation">fstopPropagation</a></li><li><a href="global.html#generateContactData">generateContactData</a></li><li><a href="global.html#getAllAddTaskFormInputs">getAllAddTaskFormInputs</a></li><li><a href="global.html#getItem">getItem</a></li><li><a href="global.html#getSearchInput">getSearchInput</a></li><li><a href="global.html#guestTime">guestTime</a></li><li><a href="global.html#handleClickPrio">handleClickPrio</a></li><li><a href="global.html#ifLocalStorageExist">ifLocalStorageExist</a></li><li><a href="global.html#ifSessionStorageExist">ifSessionStorageExist</a></li><li><a href="global.html#ifelseRegister">ifelseRegister</a></li><li><a href="global.html#informationTodo">informationTodo</a></li><li><a href="global.html#informationsFactory">informationsFactory</a></li><li><a href="global.html#initAddTask">initAddTask</a></li><li><a href="global.html#initContacts">initContacts</a></li><li><a href="global.html#loadAllIfElse">loadAllIfElse</a></li><li><a href="global.html#loadAllIfElseLocalOrSession">loadAllIfElseLocalOrSession</a></li><li><a href="global.html#loadStorage">loadStorage</a></li><li><a href="global.html#loadSummaryInnerhtml">loadSummaryInnerhtml</a></li><li><a href="global.html#loadSummaryProject">loadSummaryProject</a></li><li><a href="global.html#loadUsers">loadUsers</a></li><li><a href="global.html#loadstorageitems">loadstorageitems</a></li><li><a href="global.html#logOut">logOut</a></li><li><a href="global.html#login">login</a></li><li><a href="global.html#loginValueEmpty">loginValueEmpty</a></li><li><a href="global.html#menuInnerHTML">menuInnerHTML</a></li><li><a href="global.html#menuLoginName">menuLoginName</a></li><li><a href="global.html#moveTask">moveTask</a></li><li><a href="global.html#noCloseContent">noCloseContent</a></li><li><a href="global.html#openBordTask">openBordTask</a></li><li><a href="global.html#openContact">openContact</a></li><li><a href="global.html#openContactAdding">openContactAdding</a></li><li><a href="global.html#openContactEdition">openContactEdition</a></li><li><a href="global.html#openContactsSideMenu">openContactsSideMenu</a></li><li><a href="global.html#openDropDownMenu">openDropDownMenu</a></li><li><a href="global.html#openMenu">openMenu</a></li><li><a href="global.html#openMoveMenue">openMoveMenue</a></li><li><a href="global.html#openMoveTaskMenu">openMoveTaskMenu</a></li><li><a href="global.html#openTask">openTask</a></li><li><a href="global.html#pushTaskToUserArray">pushTaskToUserArray</a></li><li><a href="global.html#register">register</a></li><li><a href="global.html#registerGuestLogin">registerGuestLogin</a></li><li><a href="global.html#registerValueEmpty">registerValueEmpty</a></li><li><a href="global.html#renderAssignedTo">renderAssignedTo</a></li><li><a href="global.html#renderCategory">renderCategory</a></li><li><a href="global.html#renderContacts">renderContacts</a></li><li><a href="global.html#renderResults">renderResults</a></li><li><a href="global.html#renderResultsCategory">renderResultsCategory</a></li><li><a href="global.html#renderSelectedContacts">renderSelectedContacts</a></li><li><a href="global.html#renderTasks">renderTasks</a></li><li><a href="global.html#resetForm">resetForm</a></li><li><a href="global.html#saveEditedContact">saveEditedContact</a></li><li><a href="global.html#saveEditedTask">saveEditedTask</a></li><li><a href="global.html#saveNewContact">saveNewContact</a></li><li><a href="global.html#saveTask">saveTask</a></li><li><a href="global.html#saveToServer">saveToServer</a></li><li><a href="global.html#searchTaskPlace">searchTaskPlace</a></li><li><a href="global.html#searchTitleStart">searchTitleStart</a></li><li><a href="global.html#selectCategory">selectCategory</a></li><li><a href="global.html#selectContactById">selectContactById</a></li><li><a href="global.html#selectContacts">selectContacts</a></li><li><a href="global.html#selectContactsOpenTask">selectContactsOpenTask</a></li><li><a href="global.html#selectPrio">selectPrio</a></li><li><a href="global.html#selectPriority">selectPriority</a></li><li><a href="global.html#selectPriorityOpenTask">selectPriorityOpenTask</a></li><li><a href="global.html#selectSubtaskHtml">selectSubtaskHtml</a></li><li><a href="global.html#selectSubtasks">selectSubtasks</a></li><li><a href="global.html#selectTaskCategory">selectTaskCategory</a></li><li><a href="global.html#selectTaskContact">selectTaskContact</a></li><li><a href="global.html#setFilter">setFilter</a></li><li><a href="global.html#setFocusOnElement">setFocusOnElement</a></li><li><a href="global.html#setItem">setItem</a></li><li><a href="global.html#setMinDate">setMinDate</a></li><li><a href="global.html#setSubtaskData">setSubtaskData</a></li><li><a href="global.html#showEmptyHtmlAwaitfeedback">showEmptyHtmlAwaitfeedback</a></li><li><a href="global.html#showEmptyHtmlDone">showEmptyHtmlDone</a></li><li><a href="global.html#showEmptyHtmlInprogress">showEmptyHtmlInprogress</a></li><li><a href="global.html#showEmptyHtmlTodo">showEmptyHtmlTodo</a></li><li><a href="global.html#showHtml">showHtml</a></li><li><a href="global.html#showTaskCategoryBig">showTaskCategoryBig</a></li><li><a href="global.html#showTaskHtml">showTaskHtml</a></li><li><a href="global.html#showTaskNotification">showTaskNotification</a></li><li><a href="global.html#signUpBox">signUpBox</a></li><li><a href="global.html#singedUpSucces">singedUpSucces</a></li><li><a href="global.html#singedUpSuccesRemove">singedUpSuccesRemove</a></li><li><a href="global.html#sortContacts">sortContacts</a></li><li><a href="global.html#summaryDeadline">summaryDeadline</a></li><li><a href="global.html#switchToDefault">switchToDefault</a></li><li><a href="global.html#switchViewOnSize">switchViewOnSize</a></li><li><a href="global.html#timeIfElse">timeIfElse</a></li><li><a href="global.html#transferDate">transferDate</a></li><li><a href="global.html#unselectSelected">unselectSelected</a></li><li><a href="global.html#updateEmptyHtml">updateEmptyHtml</a></li><li><a href="global.html#updateProgressBar">updateProgressBar</a></li><li><a href="global.html#updateSelectedCheckboxes">updateSelectedCheckboxes</a></li><li><a href="global.html#userTime">userTime</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sat Apr 13 2024 16:04:43 GMT+0200 (Mitteleuropäische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
